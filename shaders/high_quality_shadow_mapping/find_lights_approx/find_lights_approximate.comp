#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform Push {
    uvec2 tileResolution;
    uint numZbinSlices;
    float cameraNear;
    float cameraFar;
} push;

#include "../includes/inc_zbin.glsl"
#include "../includes/inc_light_mask.glsl"

layout(set = 0, binding = 0) uniform sampler2D hzb;

layout(set = 0, binding = 1) restrict writeonly buffer tileGroupLightMaskBuffer {
    lightMask tileGroupLightMasks[];
};

//layout(set = 0, binding = 2) restrict writeonly buffer tileShadowSlotIDs;
//layout(set = 0, binding = 3) restrict writeonly buffer slotCounters;

layout(set = 0, binding = 2) restrict readonly buffer ZbinBuffer {
    zBin zBins[];
};

layout(set = 0, binding = 3) restrict readonly buffer LightMaskBuffer {
    lightMask lightMasks[];
};

uint roundUp(in uint value, in uint mult) {
    uint remainder = value % mult;

    return remainder == 0 ? 0 : value + mult - remainder;
}

uint allocateShadowSlotID(in uint inTileIndex, in uint inTileLightCount) {
    // TODO: careful that inTileLightCount is in, is this intentional?
    // TODO: any synchronization needed here?

    // Round up to next mult of 3 as 3 indices stored per uint
    inTileLightCount         = roundUp(inTileLightCount, 3);
    uint tileGroupLightCount = subgroupAdd(inTileLightCount); // TODO: is inTileLightCount correct here?
    uint tileGroupSlotID     = 0;

    // Single thread allocates space for entire tile group
    //if (subgroupElect()) {
    //    atomicAdd(...)
    //}

    uint shadowSlotID = subgroupBroadcastFirst(tileGroupSlotID);
    shadowSlotID     += subgroupExclusiveAdd(inTileLightCount);
    return shadowSlotID;
}

uint getTileIdx(in uvec2 tileCoord) {
    return tileCoord.x + tileCoord.y * push.tileResolution.x;
}

vec2 getTileNearFarDepth(in uvec2 tileCoord) {
    // Fetch shadow tile depths from 1/8th HZB. 
    // Light Mask checks against 32x32 pixels so consider a 4x4 grid of depths for mins and maxes.

    vec2 gatherCoords00 = (tileCoord + uvec2(1, 1)) / push.tileResolution;
    vec2 gatherCoords01 = (tileCoord + uvec2(3, 1)) / push.tileResolution;
    vec2 gatherCoords10 = (tileCoord + uvec2(1, 3)) / push.tileResolution;
    vec2 gatherCoords11 = (tileCoord + uvec2(3, 3)) / push.tileResolution;

    vec4 gather00 = textureGather(hzb, gatherCoords00);
    vec4 gather01 = textureGather(hzb, gatherCoords01);
    vec4 gather10 = textureGather(hzb, gatherCoords10);
    vec4 gather11 = textureGather(hzb, gatherCoords11);

    vec4 gatheredMins = min(min(gather00, gather01), min(gather10, gather11));
    vec4 gatheredMaxs = max(max(gather00, gather01), max(gather10, gather11));

    float tileNear = min(min(gatheredMins.x, gatheredMins.y), min(gatheredMins.z, gatheredMins.w));
    float tileFar  = max(max(gatheredMaxs.x, gatheredMaxs.y), max(gatheredMaxs.z, gatheredMaxs.w));

    return vec2(tileNear, tileFar);
}

ivec2 getZbinMinMaxIdx(in vec2 minMaxDepth) {
    // Exponential view space mapping to mirror calculation of zBin.
    // Slice calculation from Tiago Sous' DOOM 2016 Siggraph presentation.
    //   Interactive graph: https://www.desmos.com/calculator/bf0g6n0hqp.
    
    const float logFarNear = log(push.cameraFar / push.cameraNear);
    const float nSlices = float(push.numZbinSlices);
    const float sliceFrac1 = nSlices / logFarNear;
    const float sliceFrac2 = sliceFrac1 * log(push.cameraNear);

    const ivec2 minMaxIdx = ivec2(
        floor(log(minMaxDepth.x) * sliceFrac1 - sliceFrac2),
        floor(log(minMaxDepth.y) * sliceFrac1 - sliceFrac2)
    );

    return minMaxIdx;
}
ivec2 getZbinRangeFromIndex(in ivec2 zBinMinMaxIdx) {
    return ivec2(
        zBins[zBinMinMaxIdx.x].rangedMinLightIdx, 
        zBins[zBinMinMaxIdx.y].rangedMaxLightIdx
    );
}

uint maskToBitRange(in uint val, in uint minIdx, in uint maxIdx) {
    uint minMask = ~((1u << minIdx) - 1u); // set lowest n bits to 0
    uint maxMask = maxIdx == 31u ?          // set highest n bits to 0 to excluding active highest group
           1u << 31u                                   //  Deal with overflow 
        : (1u << (maxIdx + 1u)) - 1u; 
    
    return val & minMask & maxMask;
}

uint getTileLightGroupMask(in uvec2 tileCoord) {
    // Light mask tiles are 32x32 whereas tiles are 8x8
    uint lightMaskIdx = (tileCoord.x + tileCoord.y * push.tileResolution.x) / 4;

    // Get first 32 bits of the light mask reserved for groups
    return lightMasks[lightMaskIdx].bits[0];
}

uint intersectLightGroupMask(in ivec2 binRange, in uint lightGroupMask) {
    // Unset bits of groups which fall entirely outside of the given bin range
    if ( any(lessThan(binRange, ivec2(0))) ) return 0;

    uvec2 lightGroupRange  = binRange / 32;
    return maskToBitRange(lightGroupMask, lightGroupRange.x, lightGroupRange.y);
}

uint getTileLightMask(in uvec2 tileCoord, in uint lightGroupBit) {
    uint lightMaskIdx = (tileCoord.x + tileCoord.y * push.tileResolution.x) / 4;

    return lightMasks[lightMaskIdx].bits[lightGroupBit + 1];
}

uint intersectLightMask(in ivec2 binRange, in uint lightGroupBit, in uint lightMask) {
    // We shouldn't have any negative values in the bin range here
    //  as they should be all filtered out by the light group mask

    uvec2 uintBinRange = uvec2(binRange);
    uint maskMinLightIdx = 32 * lightGroupBit;
    uint maskMaxLightIdx = maskMinLightIdx + 31;

    if (binRange.x > maskMaxLightIdx || binRange.y < maskMinLightIdx)
        return 0;

    int localRangeMin = binRange.x - int(maskMinLightIdx);
    uint maskMinIdx = min(0, localRangeMin);

    int localRangeMax = binRange.y - int(maskMaxLightIdx);
    uint maskMaxIdx = min(31, localRangeMax);

    return maskToBitRange(lightMask, maskMinIdx, maskMaxIdx);
}

void main() {
    // Two main objectives here:
    //   - Find potentially valid lights per shadow tile
    //   - Reserve memory for storage of light lists built in the following phases

    // We only evaluate 1 shadow tile per thread instead of per-pixel

    uvec2 inTileCoord = ivec2(gl_GlobalInvocationID.xy);
    bool isValidTile = all(lessThan(inTileCoord, push.tileResolution));

    if (isValidTile) {
        const uint tileIdx         = getTileIdx(inTileCoord);
        const vec2 tileMinMaxDepth = getTileNearFarDepth(inTileCoord);
        const ivec2 zBinMinMaxIdx  = getZbinMinMaxIdx(tileMinMaxDepth);
        const ivec2 binRange       = getZbinRangeFromIndex(zBinMinMaxIdx);

        uint lightGroupMask      = getTileLightGroupMask(inTileCoord);
        lightGroupMask           = intersectLightGroupMask(binRange, lightGroupMask);

        uint tileLightCount      = 0;
        uint validLightGroupMask = 0;

        // ---- Process Light Groups (of 32) ---------------------------------------------------------------------
        while (lightGroupMask != 0) {
            uint validLightMask = 0;
            uint lightGroupBit  = findLSB(lightGroupMask);
            uint lightMask      = getTileLightMask(inTileCoord, lightGroupBit);
            lightMask           = intersectLightMask(binRange, lightGroupBit, lightMask);

            // ---- Process lights within set light groups -------------------------------------------------------
            while (lightMask != 0) {
                uint lightBit   = findLSB(lightMask);
                uint lightIdx   = lightGroupBit * 32 + lightBit;

                // TODO: Cull light against froxel
                bool validLight = true; // lightFroxelTests(...);

                lightMask      ^= 1u << lightBit; // Unset bit of processed light
                if (validLight) {
                    tileLightCount += 1;
                    validLightMask |= 1 << lightBit;
                }
            }

            uint tileGroupLightMask = subgroupOr(validLightMask);
            if (subgroupElect()) {
                // Write tile group light mask
                tileGroupLightMasks[tileIdx].bits[lightGroupBit + 1] = tileGroupLightMask;
            }

            // ---------------------------------------------------------------------------------------------------
            validLightGroupMask |= tileGroupLightMask != 0 ? 1 << lightGroupBit : 0;
            lightGroupMask      ^= 1u << lightGroupBit; // Unset bit of processed group
        }
    
        // First subgroup stores the LightGroup mask entry for the TileGroup, 
        if (subgroupElect()) {
        	tileGroupLightMasks[tileIdx].bits[0] = validLightGroupMask;
        }

        // Allocate and store each Tile ShadowSlotID
        uint shadowSlotID = allocateShadowSlotID(tileIdx, tileLightCount);
        // 

    }
}